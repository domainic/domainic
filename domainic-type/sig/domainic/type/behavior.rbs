module Domainic
  module Type
    # @since 0.1.0
    module Behavior
      @constraints: Hash[Symbol, Hash[Symbol, Constraint::Behavior]]

      def self.included: (Class | Module base) -> void

      # @since 0.1.0
      module ClassMethods : Behavior
        @intrinsic_constraints: Hash[Symbol, Hash[Symbol, Constraint::Behavior]]

        def validate: (untyped value) -> bool

        alias === validate

        def validate!: (untyped value) -> bool

        private

        def intrinsic: (Symbol constrained, Symbol constraint_name, Symbol constraint_type, ?untyped? expectation, **untyped options) -> void

        def intrinsic_constraints: () -> Hash[Symbol, Hash[Symbol, Constraint::Behavior]]

        def method_missing: (Symbol method_name, *untyped arguments, **untyped keyword_arguments) -> Behavior

        def respond_to_missing?: ...
      end

      class ValidationResult < Struct[untyped]
        attr_accessor failures(): Array[Constraint::Behavior]

        attr_accessor type_failure(): bool

        def self.new: (?failures: Array[Constraint::Behavior], ?type_failure: bool) -> instance
                    | ({ ?failures: Array[Constraint::Behavior], ?type_failure: bool }) -> instance
      end

      def initialize: (**untyped options) -> void

      def type: () -> String

      def validate: (untyped value) -> bool

      alias === validate

      def validate!: (untyped value) -> bool

      private

      def add_constraint: (Symbol constrained, Symbol constraint_name, Symbol constraint_type, ?untyped? expectation, **untyped options) -> self

      def collect_failures: (untyped value, ValidationResult result) -> ValidationResult

      def raise_type_error!: (ValidationResult result, untyped value) -> void
    end
  end
end
