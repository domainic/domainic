module Domainic
  module Type
    module Constraint
      # A class managing collections of type constraints.
      #
      # The Set class provides a structured way to manage multiple constraints,
      # organizing them by their accessor method and constraint name. It handles
      # the creation, storage, and retrieval of constraints while maintaining
      # their relationships and configuration.
      #
      # Key features:
      # - Organized storage by accessor and constraint name
      # - Dynamic constraint resolution and creation
      # - Flexible constraint lookup and enumeration
      # - Support for both symbol and string identifiers
      #
      # @example Creating and managing constraints
      #   set = Set.new
      #   set.add(:self, :type_check, :string)
      #   set.add(:length, :minimum, :range, minimum: 5)
      #
      #   set.constraint?(:self, :type_check)  # => true
      #   set.constraints  # => [StringConstraint, RangeConstraint]
      #   set.count       # => 2
      #
      # @api private
      #
      # @author {https://aaronmallen.me Aaron Allen}
      # @since 0.1.0
      class Set
        extend Forwardable

        @lookup: Hash[Behavior::accessor_symbol, Hash[Symbol, Behavior]]

        # Initialize a new empty constraint set.
        #
        # @return [void]
        def initialize: () -> void

        # Add a new constraint to the set.
        #
        # Creates and configures a new constraint instance based on the provided type
        # and configuration. If a constraint with the same accessor and name already
        # exists, it will be replaced.
        #
        # @param accessor [String, Symbol] The accessor method for the constraint
        # @param constraint_name [String, Symbol] The name for this constraint
        # @param constraint_type [String, Symbol] The type of constraint to create
        # @param expectation [Object, nil] The expected value for the constraint
        # @param options [Hash] Additional options for the constraint
        # @option options [Boolean] :abort_on_failure Whether to stop on failure
        # @option options [Boolean] :is_type_failure Whether this is a type check
        #
        # @return [void]
        def add: (String | Behavior::accessor_symbol accessor, String | Symbol constraint_name, String | Symbol constraint_type, ?untyped expectation, **__todo__ options) -> void

        # Get all constraints in the set.
        #
        # @return [Array<Behavior>] Array of all constraints
        def all: () -> Array[Behavior]

        # @yield [Behavior] The constraint to check
        # @return [Boolean] true if all constraints match.
        def all?: () -> bool
                | (Class | Module) -> bool
                | () { (Behavior) -> boolish } -> bool

        # Get the total number of constraints.
        #
        # @return [Integer] The number of constraints
        def count: () -> Integer

        alias length count

        alias size count

        # @yield [Behavior] The constraint to process
        # @return [void]
        def each: () { (Behavior) -> void } -> void

        # Check if a specific constraint exists.
        #
        # @param accessor [Symbol] The accessor method for the constraint
        # @param constraint_name [String, Symbol] The name of the constraint
        #
        # @return [Boolean] true if the constraint exists
        def exist?: (Behavior::accessor_symbol accessor, Symbol constraint_name) -> bool

        alias has_constraint? exist?

        # @yield [Behavior] The constraint to process
        # @return [Array] The results of the block.
        def filter_map: () { (Behavior) -> untyped } -> Array[Behavior]

        # Get a specific constraint by its accessor and name.
        #
        # @param accessor [Symbol] The accessor method for the constraint
        # @param constraint_name [String, Symbol] The name of the constraint
        #
        # @return [Behavior, nil] The constraint if found, nil otherwise
        def find: (Behavior::accessor_symbol accessor, Symbol constraint_name) -> Behavior?

        private

        # Ensure that the lookup hash is deep copied when duplicating.
        #
        # @param source [Set] The source object to copy
        #
        # @return [void]
        def initialize_copy: ...
      end
    end
  end
end
