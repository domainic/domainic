module Domainic
  module Type
    module Constraint
      # A class managing collections of type constraints.
      #
      # The Set class provides a structured way to manage multiple constraints,
      # organizing them by their accessor method and constraint name. It handles
      # the creation, storage, and retrieval of constraints while maintaining
      # their relationships and configuration.
      #
      # Key features:
      # - Organized storage by accessor and constraint name
      # - Dynamic constraint resolution and creation
      # - Flexible constraint lookup and enumeration
      # - Support for both symbol and string identifiers
      #
      # @example Creating and managing constraints
      #   set = Set.new
      #   set.add(:self, :string, 'being a')
      #   set.add(:length, :range, 'having length', minimum: 5)
      #
      #   set.constraint?(:self, 'being a')  # => true
      #   set.constraints  # => [StringConstraint, RangeConstraint]
      #   set.count       # => 2
      #
      # @api private
      #
      # @author {https://aaronmallen.me Aaron Allen}
      # @since 0.1.0
      class Set
        extend Forwardable

        @lookup: Hash[Type::accessor, Hash[String | Symbol, Behavior]]

        # Initialize a new empty constraint set.
        #
        # @return [void]
        def initialize: () -> void

        # Add a new constraint to the set.
        #
        # Creates and configures a new constraint instance based on the provided type
        # and configuration. If a constraint with the same accessor and name already
        # exists, it will be replaced.
        #
        # @param accessor [String, Symbol] The accessor method for the constraint
        # @param constraint_type [String, Symbol] The type of constraint to create
        # @param quantifier_description [String, Symbol] The quantifier description of the constraint when given a
        #   string that ends with "not_described" it will not be included in the constraint set description.
        # @param expectation [Object, nil] The expected value for the constraint
        # @param options [Hash] Additional options for the constraint
        # @option options [Boolean] :abort_on_failure Whether to stop on failure
        # @option options [Boolean] :is_type_failure Whether this is a type check
        #
        # @return [void]
        def add: (String | Type::accessor accessor, String | Symbol constraint_type, String | Symbol quantifier_description, ?untyped expectation, **__todo__ options) -> void

        # Get all constraints in the set.
        #
        # @return [Array<Behavior>] Array of all constraints
        def all: () -> Array[Behavior]

        # @yield [Behavior] The constraint to check
        # @return [Boolean] true if all constraints match.
        def all?: () -> bool
                | (Class | Module) -> bool
                | () { (Behavior) -> boolish } -> bool

        # Get the total number of constraints.
        #
        # @return [Integer] The number of constraints
        def count: () -> Integer

        alias length count

        alias size count

        # The aggregate description of all constraints in the set.
        #
        # @return [String] The description of all constraints
        def description: () -> String

        # @yield [Behavior] The constraint to process
        # @return [void]
        def each: () { (Behavior) -> void } -> void

        # Check if a specific constraint exists.
        #
        # @param accessor [Symbol] The accessor method for the constraint
        # @param quantifier_description [String, Symbol] The quantifier description of the constraint
        #
        # @return [Boolean] true if the constraint exists
        def exist?: (Type::accessor accessor, Symbol | String quantifier_description) -> bool

        alias has_constraint? exist?

        # Whether any constraints in the set have failed satisfaction.
        #
        # @return [Boolean] true if any constraints have failed
        def failures?: () -> bool

        # @yield [Behavior] The constraint to process
        # @return [Array] The results of the block.
        def filter_map: () { (Behavior) -> untyped } -> Array[Behavior]

        # Get a specific constraint by its accessor and name.
        #
        # @param accessor [Symbol] The accessor method for the constraint
        # @param quantifier_description [String, Symbol] The quantifier description of the constraint.
        #
        # @return [Behavior, nil] The constraint if found, nil otherwise
        def find: (Type::accessor accessor, String | Symbol quantifier_description) -> Behavior?

        # The aggregate violation description of all constraints in the set.
        #
        # @return [String] The description of all constraints
        def violation_description: () -> String

        private

        # Generate a description for a specific constraint.
        #
        # @param quantifier_description [String, Symbol] The quantifier description of the constraint
        # @param constraint_description [String] The description of the constraint
        #
        # @return [String] The description of the constraint
        def constraint_description: (String | Symbol quantifier_description, String constraint_description) -> String

        # The described constraints for a specific accessor.
        #
        # @param accessor [Symbol] The accessor method for the constraint
        #
        # @return [Hash{String, Symbol => Behavior}] The constraints for the accessor
        def described_accessor_constraints: (Type::accessor accessor) -> Hash[String | Symbol, Behavior]

        # Ensure that the lookup hash is deep copied when duplicating.
        #
        # @param source [Set] The source object to copy
        #
        # @return [void]
        def initialize_copy: ...
      end
    end
  end
end
